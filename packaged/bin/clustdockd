#!/usr/bin/env python
# -*- coding: utf-8 -*-
###############################################################################
# Author : Antoine Sax <antoine.sax@bull.net>
# Contributors :
###############################################################################
'''Provides stuff to spawn a docker cluster well configured'''

from __future__ import print_function
import sys
import argparse
import os
import logging
import re
import zmq
from ClusterShell.NodeSet import NodeSet
from ClusterShell.RangeSet import RangeSet
import msgpack
import time
import libvirt
from ipaddr import IPv4Network, AddressValueError
import subprocess as sp
import multiprocessing as mp
from configobj import ConfigObj
from lxml import etree
import cPickle
import signal
import signalfd

CONFIG_FILE = "/etc/clustdockd.conf"
DOCKER_NODE = "docker"
LIBVIRT_NODE = "libvirt"
DUMP_FILE = "/var/run/clustdockd.bin"
STATUS = {'true': True, 'false': False}


class VirtualNode(object):
    '''Represents a virtual node'''

    def __init__(self, name, host=None, ip=None, **kwargs):
        self.name = name
        self.ip = ip if ip is not None else ''
        if host:
            self.host = host
        else:
            self.host = 'localhost'
        self.clustername, self.idx = VirtualNode.split_name(self.name)
        self.unreachable = False

    @classmethod
    def split_name(cls, nodename):
        try:
            res = re.search('([a-z-_]+)(\d+)', nodename).groups()
            clustername = res[0]
            idx = int(res[1])
            return (clustername, idx)
        except AttributeError:
            _LOGGER.error("Error when splitting %s: doesn't match regex", nodename)
            return (nodename, 0)
   
    def start(self):
        """Start virtual node"""
        raise NotImplementedError("Must be redefine is subclasses") 
    
    def stop(self):
        """Stop virtual node"""
        raise NotImplementedError("Must be redefine is subclasses") 
    
    def get_ip(self):
        """Get ip of the node"""
        raise NotImplementedError("Must be redefine is subclasses") 
    
    def is_alive(self):
        """Return True if node is still defined, else False"""
        raise NotImplementedError("Must be redefine is subclasses") 


class DockerNode(VirtualNode):
    
    def __init__(self, name, img, **kwargs):
        """Instanciate a docker container"""
        super(DockerNode, self).__init__(name, **kwargs)
        self.baseimg = img
        self.docker_host = "NO_PROXY=%s DOCKER_HOST=tcp://%s:4243" % (
            self.host, self.host) if self.host != 'localhost' else ''
        self.docker_opts = kwargs.get('docker_opts', '')
        self.supl_iface = kwargs.get('add_iface', None)
        if self.supl_iface and len(self.supl_iface) == 3:
            self.supl_iface = [self.supl_iface]
        _LOGGER.debug(self.supl_iface)
        
    def start(self):
        '''Start a docker container'''
        #--cpuset-cpus {cpu_bind} \
        spawn_cmd = "%s docker run -d -t --name %s -h %s \
                --cap-add net_raw --cap-add net_admin \
                %s %s &> /dev/null" % (self.docker_host,
                                       self.name,
                                       self.name,
                                       self.docker_opts,
                                       self.baseimg)
        spawned = 1
        try:
            _LOGGER.info("trying to launch %s", spawn_cmd)
            sp.check_call(spawn_cmd, shell=True)
        except sp.CalledProcessError:
            _LOGGER.error("Something went wrong when spawning %s", self.name)
        else:
            try:
                if self.supl_iface:
                    for iface in self.supl_iface:
                        self._add_iface(iface)
                spawned = 0
            except Exception:
                self.stop()
        sys.exit(spawned)
    
    def stop(self):
        """Stop docker container"""
        rmcmd = "%s docker rm -f -v %s" % (self.docker_host, self.name)
        try:
            _LOGGER.debug("Trying to delete %s", self.name)
            sp.check_call(rmcmd, shell=True)
        except sp.CalledProcessError:
                _LOGGER.error("Something went wrong when stopping %s", self.name)
                sys.exit(1)
        sys.exit(0)
    
    def is_alive(self):
        """Return True if node is still present on the host, else False"""
        res = False
        cmd = '%s docker inspect -f "{{ .State.Running }}" %s' % (self.docker_host, self.name)
        _LOGGER.debug("Launching command: %s", cmd)
        try:
            p = sp.Popen(cmd, stdout=sp.PIPE, shell=True)
            (node_info, _) = p.communicate()
            if p.returncode == 0:
                node_info = node_info.strip()
                self.running = STATUS[node_info]
                res = True
            else:
                _LOGGER.debug("Container %s doesn't exist anymore.", self.name)
        except sp.CalledProcessError:
            _LOGGER.error("Something went wrong when getting ip of %s", self.name)
        return res
         
    def get_ip(self):
        '''Get container ip from name'''
        if self.ip != '':
            return self.ip
        ip = ''
        inspect_cmd = '%s docker inspect -f "{{ .NetworkSettings.IPAddress }}" %s' % (
            self.docker_host, self.name)
        try:
            p = sp.Popen(inspect_cmd, stdout=sp.PIPE, shell=True)
            (node_info, _) = p.communicate()
            ip = node_info.strip()
            self.ip = ip
        except sp.CalledProcessError:
            _LOGGER.error("Something went wrong when getting ip of %s", self.name)
        return ip

    def _add_iface(self, iface):
        """Add another interface to the docker container"""
        prefix = "ssh %s" % self.host if self.host != 'localhost' else ''
        br, eth, ip = iface
        try:
            # ip addr show docker0 -> check the bridge presence
            cmd = "%s ip addr show %s | grep 'inet ' | awk '{print $2}'" % (
                    prefix, 
                    br)
            p = sp.Popen(cmd, stdout=sp.PIPE, shell=True)
            (br_ip, _) = p.communicate()
        except sp.CalledProcessError as ex:
            raise Exception("Something went wrong when trying to find bridge %s", br)
            
        br_ip = br_ip.strip()
        try:
            br_net = IPv4Network(br_ip)
        except AddressValueError:
            _LOGGER.error("Bridge lookup failed: %s", br_ip)
            raise Exception("Bridge %s not found", br)
        
        # test if it's an ovs bridge
        rc = sp.call("%s ovs-vsctl br-exists %s &> /dev/null" % (
                prefix, br), shell=True)
        if rc == 0:
            # It's an ovs bridge
            cmd = "%s ovs-docker add-port %s %s %s" % (
                  prefix, br, eth, self.name
                  )
            cmd += " --ipaddress=%s" % ip if ip != "dhcp" else ""
            
            _LOGGER.debug("Trying to execute: %s", cmd)
            try:
                sp.check_call(cmd, shell=True)
            except sp.CalledProcessError:
                raise Exception("Adding interface on bridge %s failed", br)
        else:
            # it's a system bridge

            # Get the pid of the container
            cmd = "%s docker inspect -f '{{.State.Pid}}' %s" % (
                    self.docker_host,
                    self.name)
            p = sp.Popen(cmd, stdout=sp.PIPE, shell=True)
            (pid, _) = p.communicate()
            pid = pid.strip()
            if_a_name = "v%spl%s" % (eth, pid)
            if_b_name = "v%spg%s" % (eth, pid)
            cmd = 'mkdir -p /var/run/netns \n ' + \
                  'ln -s /proc/{pid}/ns/net /var/run/netns/{pid} \n ' + \
                  'ip link add {a_if} type veth peer name {b_if} \n' + \
                  'brctl addif %s {a_if} \n' % br + \
                  'ip link set {a_if} up \n' + \
                  'ip link set {b_if} netns {pid} \n' + \
                  'ip netns exec {pid} ip link set dev {b_if} name %s \n' % eth + \
                  'ip netns exec {pid} ip link set %s up\n' % eth + \
                  'rm -f /var/run/netns/{pid}'
            if self.host != 'localhost':
                cmd = 'ssh -T %s <<ENDSSH \n ' % self.host + \
                      '%s \n' % cmd + \
                      'ENDSSH'
            cmd = cmd.format(pid=pid, a_if=if_a_name, b_if=if_b_name)
            _LOGGER.debug("Trying to execute: %s", cmd)
            try:
                sp.check_call(cmd, shell=True)
            except sp.CalledProcessError:
                raise Exception("Adding interface on bridge %s failed", br)


class LibvirtNode(VirtualNode):
    
    def __init__(self, name, img, img_dir, **kwargs):
        """Instanciate a libvirt node"""
        super(LibvirtNode, self).__init__(name, **kwargs)
        self.uri = "qemu+ssh://%s/system" % self.host if self.host != 'localhost' else None 
        self.baseimg = img
        self.img_dir = img_dir
        self.supl_iface = kwargs.get('add_iface', None)
        if self.supl_iface and not isinstance(self.supl_iface, list):
            self.supl_iface = [self.supl_iface]
        
    @property
    def img_path(self):
        """Return path of the node image"""
        return os.path.join(self.img_dir, "%s.qcow2" % self.name)
    
    def get_baseimg_path(self, xmldesc):
        """Get base image path from xml description"""
        tree = etree.fromstring(xmldesc)
        path = tree.xpath("//devices/disk/source/@file")[0]
        self.baseimg_path = path

    def start(self):
        """Start libvirt virtual machine"""
        _LOGGER.debug("Trying to spawn %s on host %s", self.name, self.host)
        try:
            cvirt = libvirt.open(self.uri)
        except libvirt.libvirtError:
            _LOGGER.debug("Couldn't connect to host %s. Skipping.", self.host)
            sys.exit(1)
        mngtvirt = libvirt.open()
        # Check if base domain exists, otherwise exit
        base_dom = None
        try:
            base_dom = mngtvirt.lookupByName(self.baseimg)
        except libvirt.libvirtError:
            _LOGGER.error("Base image doesn't exist (%s). Exitting", self.baseimg)
            sys.exit(1)
        
        # check if domain already exists
        if self.name in cvirt.listDefinedDomains():
            _LOGGER.error("Image %s already exists. Skipping", self.name)
            sys.exit(1)
        
        # Get xml description of the base image
        bxml_desc = base_dom.XMLDesc()
        
        # Create new disk file for the node
        # Just save diffs from based image
        self.get_baseimg_path(bxml_desc)
        cmd = "qemu-img create -f qcow2 -b %s %s" % (self.baseimg_path, self.img_path)
        _LOGGER.info("Launching %s", cmd)
        try:
            sp.check_call(cmd, shell=True)
            cmd = "chmod a+w %s" % self.img_path
            sp.check_call(cmd, shell=True)
            _LOGGER.info("Launching %s", cmd)
        except sp.CalledProcessError:
            _LOGGER.error("Something went wrong when spawning %s", self.name)
            sys.exit(1)
        
        # Change xml content
        new_xml = self.build_xml(bxml_desc)
        if self.supl_iface:
            for iface in self.supl_iface:
                new_xml = self._add_iface(new_xml, iface)
        tmpfile = "/tmp/clustdock-def.xml"
        with open(tmpfile, 'w') as xmlfile:
            xmlfile.write(new_xml)
        # Define the new node
        try:
            try:
                cmd = "virt-customize --hostname %s -a %s" % (self.name, self.img_path)
                sp.check_call(cmd, shell=True)
            except sp.CalledProcessError:
                _LOGGER.error("Setting hostname for %s failed", self.name)
                sys.exit(1)
            cvirt.defineXML(new_xml)
            dom = cvirt.lookupByName(self.name)
            dom.create()
        except libvirt.libvirtError:
            _LOGGER.error("Domain alreay exists (%s). Exitting", self.name)
            sys.exit(1)
        # Node spawned, return True
        sys.exit(0)
    
    def stop(self):
        """Stop libvirt node"""
        cvirt = libvirt.open(self.uri)
        dom_list = cvirt.listAllDomains()
        dom = cvirt.lookupByName(self.name)
        if dom.state()[0] == libvirt.VIR_DOMAIN_RUNNING:
            _LOGGER.debug('Destroying domain %s', self.name)
            dom.destroy()
        _LOGGER.debug('Undefine domain %s', self.name)
        dom.undefine() # --remove-all-storage
        try:
            cmd = "rm -f %s" % self.img_path
            _LOGGER.debug("Launching %s", cmd)
            sp.check_call(cmd, shell=True)
        except sp.CalledProcessError:
                _LOGGER.error("Something went wrong when removing disk for %s", self.name)

    def is_alive(self):
        """Return True if node is still present on the host, else False"""
        res = False
        try:
            cvirt = libvirt.open(self.uri)
            domain = cvirt.lookupByName(self.name)
            res = True
            self.running = domain.state()[0] == libvirt.VIR_DOMAIN_RUNNING
        except libvirt.libvirtError:
            pass
        return res

    def get_ip(self):
        '''Get vm ip from domain name'''
        if self.ip != '':
            return self.ip
        ip = ''
        if not self.is_alive():
            return None
        cvirt = libvirt.open(self.uri)
        domain = cvirt.lookupByName(self.name)
        xml_desc = domain.XMLDesc()
        tree = etree.fromstring(xml_desc)
        mac = tree.xpath("//mac/@address")[0]
        _LOGGER.debug('mac of domain %s is %s', self.name, mac)
        try:
            cmd = "ip neigh | grep '%s' | awk '{print $1}'" % mac
            for retry in range(0, 20):
                p = sp.Popen(cmd, stdout=sp.PIPE, shell=True)
                (node_info, _) = p.communicate()
                ip = node_info.strip()
                if ip == '':
                    _LOGGER.debug("ip of %s is empty, retrying", self.name)
                    time.sleep(2)
                else:
                    _LOGGER.debug("ip of %s is %s", self.name, ip)
                    break

        except sp.CalledProcessError:
            _LOGGER.error("Something went wrong when getting ip of %s", node_name)
        self.ip = ip
        return ip

    def build_xml(self, xml_info):
        '''Generate new XML description for the node from the base description'''
        new_xml = []
        for line in xml_info.split('\n'):
            if self.baseimg in line:
                if self.baseimg_path in line:
                    new_xml.append(line.replace(self.baseimg_path, self.img_path))
                else:
                    new_xml.append(line.replace(self.baseimg, self.name))
            elif 'uuid' in line:
                continue
            elif 'mac address' in line:
                continue
            else:
                new_xml.append(line)
        return '\n'.join(new_xml)
    
    def __str__(self):
        return self.name
    
    def __cmp__(self, node):
        if isinstance(node, VirtualNode):
            return cmp(self.name, node.name)
        else:
            raise Exception("Cannot compare two object with different types")

    def _add_iface(self, xml, iface):
        """Add network interface to the VM"""
        desc = "<interface type='bridge'>\n" + \
               "  <source bridge='%s'/>\n" % iface + \
               "  <model type='virtio'/>\n" + \
               "</interface>\n"
        new_iface = etree.fromstring(desc)
        tree = etree.fromstring(xml)
        devices = tree.xpath("//devices")[0]
        devices.append(new_iface)
        return etree.tostring(tree)


class VirtualCluster(object):
    '''Represents a docker cluster'''

    def __init__(self, name, cfg):
        self.name = name
        self.nodes = dict()
        self.cfg = self._extract_conf(cfg)

    @property
    def nb_nodes(self):
        return len(self.nodes)

    @property
    def nodeset(self):
        return str(NodeSet.fromlist(self.nodes.keys()))
  
    def _extract_conf(self, cfg):
        """Extract cluster nodes configuration"""
        conf = {
            "default": {
            }
        }
        for key, val in cfg.iteritems():
            if isinstance(val, dict):
                rset = RangeSet(key)
                for idx in rset:
                    conf[idx] = val
            else:
                conf['default'][key] = val

        try:
            conf = format_dict(conf, **self.__dict__)
        except KeyError as ke:
            _LOGGER.error("Key '%s' not found.", ke.message)
        return conf
   
    def add_node(self, idx, host):
        """Create new node on host and add it to the cluster"""
        self.cfg['default']['host'] = host 
        conf = self.cfg['default'].copy()
        conf.update(self.cfg.get(idx, {}))
        _LOGGER.debug(conf)
        if conf['vtype'] == DOCKER_NODE:
            node = DockerNode("%s%d" % (self.name, idx), **conf)
        elif conf['vtype'] == LIBVIRT_NODE:
            node = LibvirtNode("%s%d" % (self.name, idx), **conf)
        self.nodes[node.name] = node
        return node

    def byhosts(self):
        """Return string describing on which hosts are virtual nodes"""
        byhost = {}
        for node in self.nodes.values():
            if node.host not in byhost:
                byhost[node.host] = NodeSet(node.name)
            else:
                byhost[node.host].add(node.name)
        return " - ".join([k + ':' + str(byhost[k]) for k in byhost])

     
class ClustdockServer(object):

    def __init__(self, port, profiles):
        '''docstring'''
        self.port = port
        self.profiles = profiles
        self.ctx = zmq.Context()
        self.socket = self.ctx.socket(zmq.ROUTER)
        _LOGGER.debug("trying to bind socket to port %s", port)
        self.socket.bind("tcp://*:%s" % port)
        self.clusters = dict()
    
    def load_from_file(self):
        """Load cluster list from file"""
        try:
            with open(DUMP_FILE, 'r') as dump_file:
                self.clusters = cPickle.load(dump_file)
        except IOError:
            _LOGGER.debug("File %s doesn't exists. Skipping load from file.", DUMP_FILE)
        except cPickle.PickleError:
            _LOGGER.debug("Error when loading clusters from file")
    
    def save_to_file(self):
        """Save cluster list to file"""
        try:
            with open(DUMP_FILE, 'w') as dump_file:
                cPickle.dump(self.clusters, dump_file)
        except IOError:
            _LOGGER.debug("Cannot write to file %s. Skipping", DUMP_FILE)
        except cPickle.PickleError:
            _LOGGER.debug("Error when saving clusters to file")
    
    def inventory(self):
        _LOGGER.info("Inventory of clusters")
        for cluster in self.clusters.values():
            for node in cluster.nodes.values():
                if not node.is_alive():
                    _LOGGER.info("Deleting node %s", node.name)
                    del cluster.nodes[node.name]
            _LOGGER.info("Cluster %s, #Nodes: %d, Nodes: %s", cluster.name, 
                                                              cluster.nb_nodes,
                                                              cluster.nodeset)
            if len(cluster.nodes) == 0:
                _LOGGER.info("Deleting cluster %s", cluster.name)
                del self.clusters[cluster.name]

    def process_cmd(self, cmd, clientid):
        '''Process cmd received by a client'''
        if cmd == 'list':
            self.list_clusters(clientid)
        elif cmd.startswith('spawn'):
            (_, profil, name, nb_nodes, host) = cmd.split()
            if host == 'None':
                host = None
            self.spawn_cluster(profil, name, int(nb_nodes), host, clientid)
        elif cmd.startswith('del_node'):
            name = cmd.split()[1]
            self.del_node(name, clientid)
        elif cmd.startswith('get_ip'):
            name = cmd.split()[1]
            self.get_ip(name, clientid)
        else:
            _LOGGER.debug("Ignoring cmd %s", cmd)
            self.socket.send_multipart([clientid, '', msgpack.packb('FAIL')])

    def list_clusters(self, clientid):
        '''List all clusters'''
        mylist = []
        for cluster in self.clusters.values():
            mylist.append((cluster.name, len(cluster.nodes), cluster.nodeset, cluster.byhosts()))
    
        self.socket.send_multipart([clientid, '', msgpack.packb(mylist)])
    
    def spawn_cluster(self, profil, name, nb_nodes, host, clientid):
        '''Spawn a cluster'''
        # 1: Check if cluster $name exists
        # 2: if yes, then
        #       get already spawned nodes
        # 3: select nb_nodes among availables nodes
        # 4: make those nodes not usable for future clients
        # 5: return the list of nodes to the client
        #_LOGGER.debug("len cluster.nodes: %d", len(VirtualCluster.clusters[name].nodes))
        err = []
        if self.clusters.has_key(name):
            cluster = self.clusters[name]
        elif self.profiles.has_key(profil):
            cluster = VirtualCluster(name, self.profiles[profil])
            self.clusters[cluster.name] = cluster
        else:
            msg = "Error: Profil '{}' not found in configuration file".format(profil)
            err.append(msg)
            _LOGGER.error(msg)
            self.socket.send_multipart([clientid, '', msgpack.packb(err)])
            return
        
        # Cluster defined, can continue
        _LOGGER.debug("len cluster.nodes: %d", len(cluster.nodes))
        indexes = [node.idx for node in cluster.nodes.itervalues()]
        _LOGGER.debug("indexes : %s", indexes)
        if len(indexes) == 0:
            idx_min = -1
            idx_max = -1
        else:
            idx_min = min(indexes)
            idx_max = max(indexes)
        if (idx_min == idx_max == -1):
            selected_range = range(0, nb_nodes)
        elif (idx_min - nb_nodes) >= 0:
            selected_range = range(idx_min - nb_nodes, idx_min)
        else:
            selected_range = range(idx_max + 1, idx_max + 1 + nb_nodes)
       
        processes = []
        for idx in selected_range:
            node = cluster.add_node(idx, host)
            p = mp.Process(target=node.__class__.start, args=(node,))
            p.start()
            processes.append((node.name, p))
        spawned_nodes = []
        for node_name, p in processes:
            p.join()
            if p.exitcode == 0:
                spawned_nodes.append(node_name)
            else:
                del cluster.nodes[node_name]
                err.append("Error when spawning %s" % node_name)
        
        if len(cluster.nodes) == 0:
            del self.clusters[cluster.name]

        _LOGGER.debug(spawned_nodes) 
        nodelist = str(NodeSet.fromlist(spawned_nodes))
        err.append(nodelist)
        self.socket.send_multipart([clientid, '', msgpack.packb(err)])
    
    def get_ip(self, name, clientid):
        '''Get the ip of a node if possible'''
        nodeset = NodeSet(name)
        res = []
        for nodename in nodeset:
            ip = "Unable to find IP for node %s" % nodename
            clustername, _ = VirtualNode.split_name(nodename)
            cluster = self.clusters.get(clustername, None)
            if cluster:
                node = cluster.nodes.get(nodename, None)
                if node:
                    tmp = node.get_ip()
                    if tmp != '':
                        ip = tmp
            res.append((ip, nodename))
        self.socket.send_multipart([clientid, '', msgpack.packb(res)])

    def del_node(self, name, clientid):
        '''Delete node'''
        res = ""
        nodeset = NodeSet(name)
        processes = []
        for nodename in nodeset:
            clustername, _ = VirtualNode.split_name(nodename)
            cluster = self.clusters.get(clustername, None)
            if cluster:
                node = cluster.nodes.get(nodename, None)
                if node:
                    _LOGGER.debug("deleting node %s", node.name)
                    p = mp.Process(target=node.__class__.stop, args=(node,))
                    p.start()
                    processes.append((cluster, node.name, p))
                else:
                    _LOGGER.debug("Node %s doesn't exists. Perhaps something went wrong", 
                              nodename)
                    res += "Error: Node %s doesn't exist\n" % nodename
            else:        
                _LOGGER.debug("Cluster %s doesn't exists. Perhaps something went wrong", 
                              clustername)
                res += "Error: Cluster %s doesn't exist\n" % clustername
        stopped_nodes = []
        for cluster, node_name, p in processes:
            p.join()
            if p.exitcode == 0:
                stopped_nodes.append(node_name)
                del cluster.nodes[node_name]

        for cluster in set([item[0] for item in processes]):
            if len(cluster.nodes) == 0:
                _LOGGER.debug("Deleting cluster %s", cluster.name)
                del self.clusters[cluster.name]

        nodelist = str(NodeSet.fromlist(stopped_nodes))
        _LOGGER.debug("Stopped nodes: %s", nodelist)
        res += "Stopped nodes: %s" % nodelist if nodelist != "" else "" 
        self.socket.send_multipart([clientid, '', msgpack.packb(res)])


def main(args):
    '''Main function'''
    _LOGGER.info("Starting server")
    clserver = ClustdockServer(args.port, args.cfg['profiles'])
    # Empty socker buffers
    while clserver.socket.poll(10) != 0:
        clientid, empty, message = clserver.socket.recv_multipart()
        print("Recieved control command: %s" % message)
        clserver.socket.send("FAIL")

    # Initial inventory
    clserver.load_from_file()
    clserver.inventory()
    last_exec = time.time()
    
    # Entering main loop
    _LOGGER.debug("Entering main loop")
    fd = signalfd.signalfd(-1, [signal.SIGTERM], signalfd.SFD_CLOEXEC)
    signalfd.sigprocmask(signalfd.SIG_BLOCK, [signal.SIGTERM])
    with os.fdopen(fd) as fo:
        poller = zmq.Poller()
        poller.register(clserver.socket, zmq.POLLIN)
        poller.register(fo, zmq.POLLIN)
        while True:
            try:
                items = dict(poller.poll(1000))
                if clserver.socket in items:
                    clientid, empty, cmd = clserver.socket.recv_multipart()
                    _LOGGER.debug("Something received from client: '%s'", clientid)
                    _LOGGER.debug("cmd: '%s'", cmd)
                    clserver.process_cmd(cmd, clientid)
                
                if last_exec + 60 <= time.time(): 
                    clserver.inventory()
                    last_exec = time.time()

                if fo.fileno() in items:
                    #bbytes = os.read(fd, 128)
                    #_LOGGER.debug("bytes: %s", bbytes)
                    #info = signalfd.read_siginfo(fd)
                    _LOGGER.debug("Signal received")
                    clserver.save_to_file()
                    break

            except KeyboardInterrupt:
                clserver.save_to_file()
                break
    
    clserver.socket.close()
    clserver.ctx.destroy()
    _LOGGER.info("Exiting server")


def format_dict(dico, **kwargs):
    new = {}
    for key, value in dico.items():
        if isinstance(value, dict):
            new[key] = format_dict(value, **kwargs)
        elif isinstance(value, str):
            new[key] = value.format(**kwargs)
        elif isinstance(value, tuple):
            new[key] = format_list(value, **kwargs)
        elif isinstance(value, list):
            new[key] = format_list(value, **kwargs)
        else:
            new[key] = value
    return new


def format_list(liste, **kwargs):
    new = []
    for item in liste:
        if isinstance(item, str):
            new.append(item.format(**kwargs))
        elif isinstance(item, tuple):
            new.append(format_list(item, **kwargs))
        elif isinstance(item, list):
            new.append(format_list(item, **kwargs))
    return new


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Stuff to deal with docker cluster')
    parser.add_argument('-p', '--port', help="Port to bind the deamon to",
                        default=5050)
    # Configuration file
    parser.add_argument("-c", "--cfgfile", 
                        default=CONFIG_FILE,
                        help="Configuration file. default: %(default)s")
    # Logging level
    parser.add_argument('--loglevel', '-l', metavar='LEVEL',
        help='The log level to use', default=logging.WARNING)
    _args = parser.parse_args()
    cfg = ConfigObj(_args.cfgfile, unrepr=True)
    _args.cfg = cfg
    logging.basicConfig(level=_args.loglevel,
        format="%(levelname)s|%(asctime)s|%(process)d|%(filename)s|%(funcName)s|%(lineno)d| %(message)s")
    _LOGGER = logging.getLogger()
    sys.exit(main(_args))

