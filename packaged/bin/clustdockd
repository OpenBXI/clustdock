#!/usr/bin/env python
# -*- coding: utf-8 -*-
###############################################################################
# Author : Antoine Sax <antoine.sax@bull.net>
# Contributors :
###############################################################################
'''Provides stuff to spawn a docker cluster well configured'''

from __future__ import print_function
import sys
import argparse
import os
import logging
import zmq
import time
from configobj import ConfigObj
import signal
import signalfd

import clustdock.server

CONFIG_FILE = "/etc/clustdockd.conf"


def main(args):
    '''Main function'''
    _LOGGER.info("Starting server")
    clserver = clustdock.server.ClustdockServer(args.port, args.cfg['profiles'])
    # Empty socker buffers
    while clserver.socket.poll(10) != 0:
        clientid, _, message = clserver.socket.recv_multipart()
        print("Recieved control command: %s" % message)
        clserver.socket.send("FAIL")

    # Initial inventory
    clserver.load_from_file()
    clserver.inventory()
    last_exec = time.time()

    # Entering main loop
    _LOGGER.debug("Entering main loop")
    fd = signalfd.signalfd(-1, [signal.SIGTERM], signalfd.SFD_CLOEXEC)
    signalfd.sigprocmask(signalfd.SIG_BLOCK, [signal.SIGTERM])
    with os.fdopen(fd) as fo:
        poller = zmq.Poller()
        poller.register(clserver.socket, zmq.POLLIN)
        poller.register(fo, zmq.POLLIN)
        while True:
            try:
                items = dict(poller.poll(1000))
                if clserver.socket in items:
                    clientid, _, cmd = clserver.socket.recv_multipart()
                    _LOGGER.debug("Something received from client: '%s'", str(clientid))
                    _LOGGER.debug("cmd: '%s'", cmd)
                    clserver.process_cmd(cmd, clientid)

                if last_exec + 60 <= time.time():
                    clserver.inventory()
                    last_exec = time.time()

                if fo.fileno() in items:
                    # bbytes = os.read(fd, 128)
                    # _LOGGER.debug("bytes: %s", bbytes)
                    # info = signalfd.read_siginfo(fd)
                    _LOGGER.debug("Signal received")
                    clserver.save_to_file()
                    break

            except KeyboardInterrupt:
                clserver.save_to_file()
                break

    clserver.socket.close()
    clserver.ctx.destroy()
    _LOGGER.info("Exiting server")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Stuff to deal with docker cluster')
    parser.add_argument('-p', '--port', help="Port to bind the deamon to",
                        default=5050)
    # Configuration file
    parser.add_argument("-c", "--cfgfile",
                        default=CONFIG_FILE,
                        help="Configuration file. default: %(default)s")
    # Logging level
    parser.add_argument('--loglevel', '-l', metavar='LEVEL',
        help='The log level to use', default=logging.WARNING)
    parser.add_argument('--logfile', '-f',
        type=argparse.FileType('w'),
        help='The logfile to use. Default sys.stdout', default=sys.stdout)
    _args = parser.parse_args()
    cfg = ConfigObj(_args.cfgfile, unrepr=True)
    _args.cfg = cfg
    logging.basicConfig(level=_args.loglevel,
        stream=_args.logfile,
        format="%(levelname)s|%(asctime)s|%(process)d|%(filename)s|%(funcName)s|%(lineno)d| %(message)s")
    _LOGGER = logging.getLogger()
    sys.exit(main(_args))
